header
  pagesize
  firstfree: freelist page (in memory)
  branchesIdx: btree node page (branch)
  branches: last branches storage page (new branches appended here, and into branchesIdx)
  events: last event storage page (new events appended here, and into their branch's index)

freelist page
  next: freelist page
  
  commandlist * (less than 0.9 full page)

free page
  (no data)

btree node page (branch)
  (key is ID)
  type: internal / leaf
  first: pagenumber (internal -> btree node page (branch), leaf -> branches)
  [
    key: ID
    next: pagenumber (internal -> btree node page (branch), leaf -> branches)
  ] *
  
branches
  [
    id: ID
    parentbranch: ID
    parentcommand: ID
    events: btree node page (events)  OR  eventList (where key1,key2 is unused)
    
    // IF enough events to warrant index:
    sub_idx: btree subID -> preID -> eventList (where key1 = subID, key2 = preID) 
    pre_idx: // later
    obj_idx: // later
    
  ] *
  
eventList
  [
    branch: ID
    key1: ID (e.g. sub)
    key2: ID (e.g. pre)
    events: [
      id: ID
      
      // Let's leave this out for now. Find out why this should be here.
      // the future event that merged in this event into the branch
      [ mergedId: ID (event) ]+ 
    ] *
    prev: eventList // rest of earlier events in case of page overflow
  ] *

btree node page (events)
  (key is ID)
  type: internal / leaf
  first: pagenumber (internal -> btree node page (events), leaf -> events)
  [
    key: ID
    next: pagenumber 
  ] *
  
Value: size <= (pagesize / 128): inline. Otherwise: (pagenumber: values, idx).
  
events
  [
    id: ID
    add: [ sub, pre, obj: ID ] *
    del: [ sub, pre, obj: ID ] *
    set: [ sub, pro: ID, value: Value ] *
    clr: [ sub, pro: ID ] *
  ] *
  
values
  [
    part: bytes
    next: (pagenumber: values, idx)
  ] *

header
  pagesize
  firstfree: freelist page (in memory)
  branchesIdx: btree node page (branch)
  lastBranches: last branches storage page
  commandsIdx: btree ID -> commands

freelist page
  next: freelist page
  
  commandlist * (less than 0.9 full page)

free page
  (no data)

btree node page (branch)
  (key is ID)
  type: internal / leaf
  first: pagenumber (internal -> btree node page (branch), leaf -> branches)
  [
    key: ID
    next: pagenumber (internal -> btree node page (branch), leaf -> branches)
  ] *
  
branches
  [
    id: ID
    parentbranch: ID
    parentcommand: ID
    commands: btree node page (commands)
    sub_idx: btree subID -> preID -> commandlist
    pre_idx: // later
    obj_idx: // later
    
  ] *
  
commandlist
  [
    branch: ID
    key1: ID (e.g. sub)
    key2: ID (e.g. pre)
    commands: [
      id: ID
      [ mergedId: ID (command) ]+ // the command that merged in this command into the branch
    ] *
    prev: commandlist // rest of earlier commands in case of page overflow
  ] *

btree node page (commands)
  (key is ID)
  type: internal / leaf
  first: pagenumber (internal -> btree node page (commands), leaf -> commands)
  [
    key: ID
    next: pagenumber 
  ] *
  
Value: size <= (pagesize / 128): inline. Otherwise: (pagenumber: values, idx).
  
commands
  [
    id: ID
    add: [ sub, pre, obj: ID ] *
    del: [ sub, pre, obj: ID ] *
    set: [ sub, pro: ID, value: Value ] *
    clr: [ sub, pro: ID ] *
  ] *
  
values
  [
    part: bytes
    next: (pagenumber: values, idx)
  ] *
  
  
-------

AtomicWrite (id=X1, pages = ..., otherWriters = [parent])
  if other latest write in progress from [sender]
    latestWrite.next = this
    this.prev = latestWrite
  save as latest write from [sender]
  if collected all other writes for (id, otherWriters)
    if this write.prev == null
      finish this write
        finish next (rec.)
